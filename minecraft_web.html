<!DOCTYPE html>
<html lang="en">
	<head>
		<title>minecraft</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			#blocker {
				position: absolute;
				width: 100%;
				height: 100%;
				background-color: rgba(0,0,0,0.5);
			}
			#instructions {
				width: 100%;
				height: 100%;

				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;

				text-align: center;
				font-size: 14px;
				cursor: pointer;
			}
		</style>
	</head>
	<body>
		<div id="blocker">
			<div id="instructions">
				<p style="font-size:36px">
					Click to play
				</p>
				<p>
					Move: WASD<br/>
					Jump: SPACE<br/>
					Look: MOUSE
				</p>
			</div>
		</div>

		<script type="module">
			import * as THREE from './build/three.module.js';
			import { MCFirstPersonControls } from './jsm/controls/MCFirstPersonControls.js';
			let camera, scene, renderer, MCFcontrols,controls;
			const objects = [];
			let prevTime = performance.now();

			init();
			animate();

			function init() {
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera.position.y = 4;
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xccffff );
				scene.fog = new THREE.Fog( 0xffffff, 0, 750 );

				//light*********************************************************************
				const light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
				light.position.set( 0.5, 1, 0.75 );
				scene.add( light );
				//**************************************************************************

				//controls = new PointerLockControls( camera, document.body );
				MCFcontrols = new MCFirstPersonControls( camera, document.body ,objects,scene);
				controls=MCFcontrols.controls;

				const blocker = document.getElementById( 'blocker' );
				const instructions = document.getElementById( 'instructions' );

				instructions.addEventListener( 'click', function () {
					controls.lock();
				} );

				controls.addEventListener( 'lock', function () {
					instructions.style.display = 'none';
					blocker.style.display = 'none';
				} );

				controls.addEventListener( 'unlock', function () {
					blocker.style.display = 'block';
					instructions.style.display = '';
				} );

				scene.add( controls.getObject() );

				const onKeyDown = function ( event ) {
					switch ( event.code ) {
						case 'ArrowUp':
						case 'KeyW':
							MCFcontrols.moveForward = true;
							break;
						case 'ArrowLeft':
						case 'KeyA':
							MCFcontrols.moveLeft = true;
							break;
						case 'ArrowDown':
						case 'KeyS':
							MCFcontrols.moveBackward = true;
							break;
						case 'ArrowRight':
						case 'KeyD':
							MCFcontrols.moveRight = true;
							break;
						case 'Space':
							if (MCFcontrols.canJump) MCFcontrols.velocity.y += Math.sqrt(2 * MCFcontrols.worldOption.g * 7.74 * MCFcontrols.personOption.jumpHeight);
							MCFcontrols.canJump = false;
							break;
					}
				};

				const onKeyUp = function ( event ) {
					switch ( event.code ) {
						case 'ArrowUp':
						case 'KeyW':
							MCFcontrols.moveForward = false;
							break;
						case 'ArrowLeft':
						case 'KeyA':
							MCFcontrols.moveLeft = false;
							break;
						case 'ArrowDown':
						case 'KeyS':
							MCFcontrols.moveBackward = false;
							break;
						case 'ArrowRight':
						case 'KeyD':
							MCFcontrols.moveRight = false;
							break;
					}
				};
				document.addEventListener( 'keydown', onKeyDown );
				document.addEventListener( 'keyup', onKeyUp );

				// floor*************************************************************************************

				// objects**************************************************************************************
				const boxGeometry = new THREE.BoxGeometry( 1, 1, 1 ).toNonIndexed();

				//let position = boxGeometry.attributes.position;

				//set material of minecraft
				const Toptexture = THREE.ImageUtils.loadTexture('images/grasstop.jpg');
				const Sidetexture = THREE.ImageUtils.loadTexture('images/grassside.jpg');
				const Bottexture = THREE.ImageUtils.loadTexture('images/grassbotton.jpg');
				Toptexture.magFilter = THREE.NearestFilter;
				Sidetexture.magFilter = THREE.NearestFilter;
				Bottexture.magFilter = THREE.NearestFilter;

				const texture6face = [
					new THREE.MeshPhongMaterial({map:Sidetexture}),
					new THREE.MeshPhongMaterial({map:Sidetexture}),
					new THREE.MeshPhongMaterial({map:Toptexture}),
					new THREE.MeshPhongMaterial({map:Bottexture}),
					new THREE.MeshPhongMaterial({map:Sidetexture}),
					new THREE.MeshPhongMaterial({map:Sidetexture}),
				];
				const boxMaterial = new THREE.MeshFaceMaterial(texture6face);
				for ( let i = 0; i < 500; i ++ ) {
					const box = new THREE.Mesh( boxGeometry, boxMaterial );
					box.position.x = Math.floor( Math.random() * 20 - 10 ) * 2;
					box.position.y = Math.floor( Math.random() * 20 ) * 2 ;
					box.position.z = Math.floor( Math.random() * 20 - 10 ) * 2;

					scene.add( box );
					objects.push( box );
				}
				//set a standpoint
				const box = new THREE.Mesh( boxGeometry, boxMaterial );
				box.position.set(0,0,0);
				scene.add( box );
				objects.push( box );
				//*****************



				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate );
				const time = performance.now();
				if ( controls.isLocked === true ) {
					const delta = (time - prevTime) / 1000;
					MCFcontrols.update(delta);
				}

				prevTime = time;
				renderer.render( scene, camera );
			}

		</script>
	</body>
</html>
